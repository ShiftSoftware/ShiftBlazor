@using System.Linq.Expressions
@using Microsoft.AspNetCore.Components.Forms
@using System.Collections
@using System.Text.Json

@typeparam T where T : IList
@typeparam TItem
@namespace ShiftSoftware.ShiftBlazor.Components

<MudCard Elevation="2" Class="mt-3">
    <MudCardHeader Class="pt-1 pb-1 background-gray">
        <CardHeaderContent>
            <MudStack Row>
                @if (TitleTemplate == null)
                {
                    <MudStack Row>
                        <MudText Typo="Typo.subtitle2">@Title</MudText>
                        <ValidationMessage For="ValueExpression" />
                    </MudStack>
                }
                else
                {
                    @TitleTemplate
                }
                <MudSpacer/>

                @if (!DisableCounter)
                {
                    <MudText Color="Mode > FormModes.Archive && Value.Count < Min && UseLimits ? Color.Error : Color.Default">
                        @if (UseLimits)
                        {
                            <text>@Value.Count / @Math.Max(Min, 0)@(Max == 0 ? "+" : $"-{Max}")</text>
                        }
                        else
                        {
                            <text>@Value.Count</text>
                        }
                    </MudText>
                }
            </MudStack>
        </CardHeaderContent>
    </MudCardHeader>

    <MudCardContent Class="pt-2 pb-2">
        <MudGrid Spacing="3">

            @if (FieldHeader != null)
            {
                <MudItem lg="11" md="11" sm="11" xs="11">
                    @FieldHeader(this)
                </MudItem>

                <MudItem lg="1" md="1" sm="1" xs="1"></MudItem>
            }

            @if (FieldBody != null)
            {
                @foreach (var item in Value)
                {
                    <MudItem @key="item" lg="12" md="12" sm="12" xs="12">
                        <SlideDown Hide="ItemsToRemove.Contains(item)" OnTransitionEnd="() => Remove(item)">
                            <MudGrid>
                                <MudItem lg="11" md="11" sm="11" xs="11">
                                    @FieldBody((TItem)item)
                                </MudItem>
                                <MudItem lg="1" md="1" sm="1" xs="1">
                                    @if (Mode > FormModes.Archive)
                                    {
                                        @if (RemoveButtonTempalte == null)
                                        {
                                            @GetRemoveButton((TItem)item)
                                        }
                                        else
                                        {
                                            @RemoveButtonTempalte(new(this, (TItem)item))
                                        }
                                    }
                                </MudItem>
                            </MudGrid>
                        </SlideDown>
                    </MudItem>
                }
            }

            @if (Mode > FormModes.Archive )
            {
                if (FieldFooter == null)
                {
                    <SlideDown Toggle="!UseLimits || Value.Count < Max || Max == 0" Style="margin:auto; margin-top:15px;">
                        <MudButton Variant="Variant.Filled"
                                   Color="Color.Info"
                                   Size="Size.Small"
                                   OnClick="CreateNew"
                                   StartIcon="@Icons.Material.Filled.Add">
                            Add Line
                        </MudButton>
                    </SlideDown>
                }
                else
                {
                    @FieldFooter(this)
                }
            }
        </MudGrid>
    </MudCardContent>
</MudCard>

@code {

    [CascadingParameter]
    public FormModes? Mode { get; set; }

    [CascadingParameter]
    public EditContext? EditContext { get; set; }

    [Parameter] public T Value { get; set; } = default!;
    [Parameter] public Expression<Func<T>> ValueExpression { get; set; } = default!;
    [Parameter] public EventCallback<T> ValueChanged { get; set; } = default!;

    [Parameter]
    public string? Title { get; set; }

    [Parameter]
    public int Min { get; set; }

    [Parameter]
    public int Max { get; set; }

    [Parameter]
    public bool DisableCounter { get; set; }

    // ========= Template Parameters =========
    [Parameter]
    public RenderFragment<MultiItemField<T, TItem>>? FieldHeader { get; set; }

    [Parameter]
    public RenderFragment<TItem>? FieldBody { get; set; }

    [Parameter]
    public RenderFragment<MultiItemField<T, TItem>>? FieldFooter { get; set; }

    [Parameter]
    public RenderFragment<RemoveContext>? RemoveButtonTempalte { get; set; }

    [Parameter]
    public RenderFragment? TitleTemplate { get; set; }

    private Type DTOType;
    private bool UseLimits = false;
    private FieldIdentifier fieldIdentifier;
    private ValidationMessageStore? InternalMessageStore;

    public MultiItemField()
    {
        DTOType = typeof(T).GetGenericArguments().First();
    }

    protected override void OnInitialized()
    {
        UseLimits = ((Max > 0 || Min > 0) && Min <= Max) || (Min > 0 && Max == 0);
        fieldIdentifier = FieldIdentifier.Create(ValueExpression);

        if (UseLimits)
        {
            if (EditContext != null)
            {
                InternalMessageStore = new(EditContext);
                EditContext.OnValidationRequested += (sender, eventArgs) =>
                {
                    InternalMessageStore.Clear();
                    if (Value.Count < Min)
                    {
                        InternalMessageStore.Add(fieldIdentifier, $"At least {Min} items are required.");
                    }
                };
            }

            if (Mode == FormModes.Create)
            {
                var minItemCount = Min;
                var count = Value.Count;

                while (minItemCount-- > count)
                {
                    Value.Add(Activator.CreateInstance(DTOType));
                }
                ValueChanged.InvokeAsync(Value);
            }
        }

        base.OnInitialized();
    }

    public void CreateNew()
    {
        InternalMessageStore?.Clear();

        if (!UseLimits || Value.Count < Max || Max == 0)
        {
            Value.Add(Activator.CreateInstance(DTOType));
            ValueChanged.InvokeAsync(Value);
        }
    }

    private void AddRemoveTransition(object item)
    {
        ItemsToRemove.Add(item);
    }

    private HashSet<object> ItemsToRemove = [];

    public void Remove(object item)
    {
        if (ItemsToRemove.Contains(item))
        {
            ItemsToRemove.Remove(item);
            Value.Remove(item);
            ValueChanged.InvokeAsync(Value);
        }
    }

    private RenderFragment GetRemoveButton(object item)
    {
        return @<text>
            <MudIconButton ButtonType="ButtonType.Button"
                           Style="margin:10px;"
                           Variant="Variant.Text"
                           Color="Color.Default"
                           Size="Size.Small"
                           OnClick="() => AddRemoveTransition(item)"
                           Icon="@Icons.Material.Filled.Delete" />
        </text>;
    }

    public class RemoveContext
    {
        public TItem Item { get; set; }
        public Action Remove;

        public RemoveContext(MultiItemField<T, TItem> multiItemField, TItem item)
        {
            Item = item;
            Remove = () => multiItemField.Remove(item!);
        }
    }
}
